%!TEX root=cs112S2015-lab9.tex
% mainfile: cs112S2015-lab9.tex

\input{labspre.tex}

\usepackage[compact]{titlesec}

\begin{document} \MYTITLE{Laboratory Assignment Nine: A Queue-Based Solution to the Josephus Problem}
\MYHEADERS{Laboratory Assignment Nine}{Due: April 2, 2015}

\section*{Introduction}

  Many real-world programs use the queue abstract data type (ADT) to solve a problem.  For instance, as discussed in
  class, an operating system may use a round-robin scheduler that leverages a queue to determine which process it should
  execute next. In this laboratory assignment, you will use a linked-list-based queue, called the {\tt NodeQueue}, to
  run a ``simulator'' that can solve the Josephus problem. Then, you will analyze the source-code of the simulator to
  determine its worst-case time complexity.  Finally, you will extend the solver so that it accepts command-line
  arguments and use this enhanced version to conduct a comprehensive study of the method's time efficiency.

\section*{Learning About the Queue}

  Before you start to extend the implementation of the provided {\tt JosephusSolver}, you should take some time to learn
  more about the queue ADT.  What are the methods that the queue provides?  What is the difference between an {\tt
    ArrayQueue} and a {\tt NodeQueue}? What is an example of a problem that can be solved using the queue? Your response
  to the previous question should include a brief introduction to the problem and a discussion of how the queue is
  incorporated into the solution. For instance, you could explain a program that you have previously implemented that
  manipulated a queue to solve a problem.  Alternatively, you can study books, articles, and online sources to
  investigate a well-known problem that can be solved through the use of a queue.  Please see the instructor if you have
  questions about this part of the assignment.

\section*{Using Simulation to Solve the Josephus Problem}

  Many children have played the game of ``hot potato'' that requires them to sit in a circle and pass an object around
  the circle until a leader rings a bell or stops playing some music.  At this point in the game, the child holding the
  potato must stop playing the game and, after the remaining children move closer together in the circle, the game
  continues in the same fashion. This game play continues until there is only one child left, who is then declared the
  winner.

  It turns out that this game was first recorded by Flavius Josephus, a first century Jewish historian who was a solider
  in a Jewish-Roman war.  It is possible to use a queue to ``simulate'' the process of playing this game and then
  quickly determine who will win.  \mbox{After typing} the command {\tt git pull} in the {\tt cs112S2014-share}
  repository, you will see that there is \mbox{now a} {\tt labs/lab8/} directory that contains a {\tt build.xml} file, a
  {\tt net-datastructures-5-0.jar} Java archive, and {\tt JosephusSolver.java} file in the {\tt
    src/edu/allegheny/solver/} directory.  You can run this program by typing {\tt ant JosephusSolver} in the terminal
  or {\tt :Ant JosephusSolver} \mbox{in GVim}.

  If you study {\tt JosephusSolver.java} you will notice that it contains a {\tt main} method that creates different
  groups of children and then runs the solver by specifying a group of children and a stopping point for each round.
  While this approach is suitable for demonstrating the use of the solver, it is not ideal if you need to run a series
  of experiments to evaluate the efficiency of this technique. Therefore, you should modify the program so that it
  accepts two command-line arguments: the number of children involved in the simulated game and the number of steps for
  which each round must be run. Next, you should enhance the program so that it automatically generates a list of
  ``children'' and calls the solver with both an instance of the child-populated {\tt NodeQueue} and the steps
  parameter. Finally, you should add timing code to the program that can calculate how long it takes to run the solver.
  What is the program's output? How did you determine it worked correctly?

\section*{Evaluating the Efficiency of the Solver}

  After you have finished enhancing the {\tt JosephusSolver} by adding command lines and timing code, you should
  carefully study the method called {\tt Josephus}.  Using the big-O notation, what is the worst-case time complexity of
  this method?  In addition to stating your chosen complexity, you should clearly justify your choice. Does this
  analysis suggest that this solver is efficient or inefficient?

  Finally, you should conduct an empirical study to evaluate the run-time efficiency of the {\tt JosephusSolver}.  To
  develop an accurate understanding of the solver's performance, you should pick five different values for {\tt k} and
  run the solver with ten different groups of children of increasing size. For each value of {\tt k} and size of the
  group, you should run the solver ten times and calculate the arithmetic mean of the execution times. Make sure that
  you pick values for {\tt k} and the size of the group that will give an accurate picture of worst-case time
  efficiency. Next, you should create a table of data or a graph that summarizes your results. Does the data from your
  experimental evaluation confirm the worst-case time complexity that your derived? Why or why not?

\section*{Summary of the Required Deliverables}

  This assignment invites you to submit a signed and printed version of the following deliverables:

  \begin{enumerate}
  % \itemsep0pt

  \item A complete description of a problem that can be solved by using the queue abstract data type

  \item The properly commented version of {\tt JosephusSolver.java} and any other Java files you create

  \item The output from five separate runs of {\tt JosephusSolver}, demonstrating it's correctness

  \item A written report that provides a response to all of the questions posed in this assignment

  \item A justified statement of the worst-case time complexity for the {\tt Josephus} method

  \item A written analysis of the {\tt JosephusSolver}'s efficiency when it is run in different configurations

  \item A reflective commentary on the challenges that you faced when completing this assignment

  \end{enumerate}

  Along with turning in a printed version of these deliverables, you should ensure that everything is also available in
  the repository that is named according to the convention {\tt cs112S2014-<your user name>}. Please note that students
  in the class are responsible for completing and submitting their own version of this assignment.    While it is
  acceptable for members of this class to have high-level conversations, you should not share source code or full
  command lines with your classmates.  Deliverables that are nearly identical to the work of others will be taken as
  evidence of violating the \mbox{Honor Code}.  Please see the instructor if you have questions about the policies for
  this assignment.

  \end{document}
